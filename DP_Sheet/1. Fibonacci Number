1. Fibonacci Number
P: https://leetcode.com/problems/fibonacci-number/

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.

Constraints: 0 <= n <= 30
So the Recursive Solution also works.

Method-1: Brute Force; Recursion; TC: O(2^n); SC: O(n)
Code:
class Solution:
    def fib(self, n: int) -> int:
        if(n==0 or n==1):
            return n
        else:
            return self.fib(n-1)+self.fib(n-2)
            
Method-2: Bottom-Up Approach using Memoization; TC: O(n); SC: O(n)
Improve upon the recursive option by using iteration, still solving for all of the sub-problems
and returning the answer for N, using already computed Fibonacci values. In using a bottom-up approach,
we can iteratively compute and store the values, only returning once we reach the result.
Algorithm:
- If N is less than or equal to 1, return N
- Otherwise, iterate through N, storing each computed answer in an array along the way.
- Use this array as a reference to the 2 previous numbers to calculate the current Fibonacci number.
- Once we've reached the last number, return it's Fibonacci number.
Code:
class Solution:
    def fib(self, n: int) -> int:
        if(n<=1):
            return n
        else:
            return self.memoize(n)
    
    def memoize(self, n: int) -> {}:
        cache = {0:0 , 1:1}
     #Since range is exclusive and we want to include N, we need to put N+1.
        for i in range(2, n+1):
            cache[i] = cache[i-1] + cache[i-2]
        return cache[n]

Time complexity : O(N). Each number, starting at 2 up to and including N, is visited, computed and then stored for O(1)O(1) access later on.
Space complexity : O(N). The size of the data structure is proportionate to N.
        
Method-3: Using MATH; TC: O(1); SC: O(1)
Use the golden ratio formula to calculate the Nth Fibonacci number.
Code:
class Solution:
    def fib(self, n: int) -> int:
        golden_ratio = (1 + 5 ** 0.5) / 2
        return int((golden_ratio ** n + 1) / 5 ** 0.5)
        
Clear DP Memoized Solution:
Code:
class Solution:
    def fib(self, n: int) -> int:
        dp = [-1]*(n+1)
        if(n <= 1):
            return n
        #if previously the state has been visited and stored, then return
        if(dp[n]!= -1):
            return dp[n]
        #Memoize the answer
        dp[n] = self.fib(n-1) + self.fib(n-2)
        return dp[n]
        
Iterative DP Code(Most Optimized Code):
class Solution:
    def fib(self, n: int) -> int:
        if(n==0):
            return 0
        dp = [-1]*(n+1)
        dp[0] = 0
        dp[1] = 1
        for i in range(2,n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
